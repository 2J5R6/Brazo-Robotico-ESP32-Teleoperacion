/*
 * SPRINT 2 - RECEPTOR (ESP32-S3 en Brazo Rob√≥tico) - VERSI√ìN FUNCIONAL
 * Basado en Sprint 1 (que funciona) + Filtros simples
 * 
 * MEJORAS vs Sprint 1:
 * - Recibe datos YA FILTRADOS del transmisor
 * - Suavizado incremental mejorado (menos tremor)
 * - MPU del brazo opcional para feedback
 * 
 * Hardware: ESP32-S3 + 2 Servos + MPU6500 (opcional)
 * Comunicaci√≥n: ESP-NOW broadcast
 */

#include <esp_now.h>
#include <WiFi.h>
#include <ESP32Servo.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>

// ========== CONFIGURACI√ìN DE PINES ==========
#define SERVO1_PIN 6
#define SERVO2_PIN 7
#define LED_PIN 48
#define SDA_PIN 8
#define SCL_PIN 10

// ========== OBJETOS GLOBALES ==========
Servo servo1;
Servo servo2;
Adafruit_MPU6050 mpuBrazo;
bool mpuBrazoReady = false;

// ========== ESTRUCTURA ESP-NOW (igual que transmisor) ==========
typedef struct struct_message {
  float accelX;
  float accelY;
  float accelZ;
  float gyroX;
  float gyroY;
  float gyroZ;
  unsigned long timestamp;
  uint8_t handPosition;  // 0=abajo (servo1), 1=arriba (servo2)
} struct_message;

struct_message receivedData;

// ========== VARIABLES DE CONTROL ==========
int servo1Position = 90;
int servo2Position = 90;
uint8_t activeServo = 1;
unsigned long lastReceiveTime = 0;
const unsigned long TIMEOUT = 500;

const float ACCEL_MIN = -4.0;
const float ACCEL_MAX = 4.0;
const int SERVO_MIN = 0;
const int SERVO_MAX = 180;

// ========== CALLBACK ESP-NOW ==========
void OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len) {
  memcpy(&receivedData, incomingData, sizeof(receivedData));
  lastReceiveTime = millis();
  activeServo = receivedData.handPosition;
  digitalWrite(LED_PIN, HIGH);
  
  // Los datos YA VIENEN FILTRADOS del transmisor
  // Mapear accel de -10 a +10 m/s¬≤ a 0-180¬∞
  int targetAngle = map((int)(receivedData.accelX * 10), -100, 100, SERVO_MIN, SERVO_MAX);
  targetAngle = constrain(targetAngle, SERVO_MIN, SERVO_MAX);
  
  // Suavizado adicional: mover hacia el objetivo gradualmente
  int currentPos = (activeServo == 0) ? servo1Position : servo2Position;
  int diff = targetAngle - currentPos;
  
  // Con datos filtrados, podemos ser m√°s agresivos en el movimiento
  int step = (abs(diff) > 15) ? 8 : 2;
  int newPos = currentPos;
  
  if (diff > 0) {
    newPos = min(currentPos + step, targetAngle);
  } else if (diff < 0) {
    newPos = max(currentPos - step, targetAngle);
  }
  
  // Aplicar posici√≥n al servo activo
  if (activeServo == 0) {
    servo1Position = newPos;
    servo1.write(servo1Position);
  } else {
    servo2Position = newPos;
    servo2.write(servo2Position);
  }
  
  // Debug cada 20 recepciones
  static int debugCounter = 0;
  if (debugCounter++ >= 20) {
    debugCounter = 0;
    Serial.print("‚úì RX FILTRADO | AccelX:");
    Serial.print(receivedData.accelX, 2);
    Serial.print(" | Target:");
    Serial.print(targetAngle);
    Serial.print("¬∞ | Actual:");
    Serial.print(newPos);
    Serial.print("¬∞ | Mano:");
    Serial.print(activeServo == 0 ? "ABAJO" : "ARRIBA");
    Serial.print(" | Servo");
    Serial.println(activeServo + 1);
  }
}

// ========== SETUP ==========
void setup() {
  Serial.begin(115200);
  delay(3000);
  
  pinMode(LED_PIN, OUTPUT);
  
  // Parpadeo inicial
  for(int i = 0; i < 10; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    delay(100);
  }
  
  Serial.println();
  Serial.println("========================================");
  Serial.println("   SPRINT 2 - RECEPTOR");
  Serial.println("   CON FILTRO DE MEDIA M√ìVIL");
  Serial.println("========================================");
  Serial.println();
  Serial.println("LED parpade√≥ 10 veces - Sistema arrancando...");
  Serial.println();
  
  // WiFi
  Serial.print("[1/5] WiFi... ");
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  delay(100);
  Serial.println("OK");
  
  // Servos
  Serial.print("[2/5] Servos... ");
  ESP32PWM::allocateTimer(0);
  ESP32PWM::allocateTimer(1);
  servo1.setPeriodHertz(50);
  servo2.setPeriodHertz(50);
  servo1.attach(SERVO1_PIN, 500, 2400);
  servo2.attach(SERVO2_PIN, 500, 2400);
  servo1.write(90);
  servo2.write(90);
  Serial.println("OK (GPIO6, GPIO7)");
  
  // Test de servos
  Serial.print("    Testeando servos... ");
  servo1.write(45);
  delay(300);
  servo1.write(135);
  delay(300);
  servo1.write(90);
  servo2.write(45);
  delay(300);
  servo2.write(135);
  delay(300);
  servo2.write(90);
  Serial.println("OK (movieron)");
  
  // ESP-NOW
  Serial.print("[3/5] ESP-NOW... ");
  if (esp_now_init() != ESP_OK) {
    Serial.println("ERROR!");
    while(1) {
      digitalWrite(LED_PIN, !digitalRead(LED_PIN));
      delay(200);
    }
  }
  esp_now_register_recv_cb(OnDataRecv);
  Serial.println("OK");
  
  // MPU6500 (OPCIONAL - feedback)
  Serial.print("[4/5] MPU6500 Brazo (feedback)... ");
  Wire.begin(SDA_PIN, SCL_PIN);
  Wire.setClock(100000);
  delay(100);
  if (mpuBrazo.begin()) {
    mpuBrazoReady = true;
    mpuBrazo.setAccelerometerRange(MPU6050_RANGE_8_G);
    mpuBrazo.setGyroRange(MPU6050_RANGE_500_DEG);
    mpuBrazo.setFilterBandwidth(MPU6050_BAND_21_HZ);
    Serial.println("OK (activo)");
  } else {
    mpuBrazoReady = false;
    Serial.println("NO DETECTADO (contin√∫a sin √©l)");
  }
  
  // Listo
  Serial.println("[5/5] Inicializaci√≥n completa");
  Serial.println();
  Serial.println("========================================");
  Serial.println("   SISTEMA LISTO - FILTRADO ACTIVO");
  Serial.println("========================================");
  Serial.println("Datos recibidos YA est√°n filtrados");
  Serial.println("MPU local: " + String(mpuBrazoReady ? "ACTIVO" : "DESACTIVADO"));
  Serial.println("Esperando datos del Transmisor...");
  Serial.println();
  
  // Parpadeo de confirmaci√≥n
  for(int i=0; i<3; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(300);
    digitalWrite(LED_PIN, LOW);
    delay(300);
  }
}

// ========== LOOP ==========
void loop() {
  static unsigned long lastPrint = 0;
  static unsigned long lastFeedback = 0;
  static int counter = 0;
  
  // Apagar LED
  if (millis() - lastReceiveTime > 50) {
    digitalWrite(LED_PIN, LOW);
  }
  
  // Contador si no hay datos
  if (millis() - lastPrint >= 1000) {
    lastPrint = millis();
    
    if (lastReceiveTime == 0 || (millis() - lastReceiveTime >= TIMEOUT)) {
      Serial.print("[");
      Serial.print(counter++);
      Serial.println("] Esperando datos...");
    }
  }
  
  // Feedback del MPU local (cada 2 segundos)
  if (mpuBrazoReady && (millis() - lastFeedback >= 2000)) {
    lastFeedback = millis();
    
    sensors_event_t accel, gyro, temp;
    mpuBrazo.getEvent(&accel, &gyro, &temp);
    
    Serial.println("\n--- FEEDBACK MPU BRAZO ---");
    Serial.print("Posici√≥n Real | X:");
    Serial.print(accel.acceleration.x, 2);
    Serial.print(" Y:");
    Serial.print(accel.acceleration.y, 2);
    Serial.print(" Z:");
    Serial.print(accel.acceleration.z, 2);
    Serial.println(" m/s¬≤");
    Serial.print("Servos | S1:");
    Serial.print(servo1Position);
    Serial.print("¬∞ S2:");
    Serial.print(servo2Position);
    Serial.println("¬∞\n");
  }
  
  // Timeout - volver a centro
  if (lastReceiveTime > 0 && (millis() - lastReceiveTime > TIMEOUT)) {
    if (servo1Position != 90) {
      servo1Position += (servo1Position < 90) ? 1 : -1;
      servo1.write(servo1Position);
    }
    if (servo2Position != 90) {
      servo2Position += (servo2Position < 90) ? 1 : -1;
      servo2.write(servo2Position);
    }
    delay(20);
  }
  
  delay(10);
}

float servo2Position = 90.0;
unsigned long lastReceiveTime = 0;
const unsigned long TIMEOUT = 500;

// ========== VARIABLES DE CALIBRACI√ìN BRAZO ==========
float offsetBrazoAccelY = 0;
float offsetBrazoGyroY = 0;
float offsetBrazoGyroZ = 0;
bool brazoCalibrated = false;

// ========== VARIABLES PARA COMPENSACI√ìN ==========
float brazoAngleEstimate = 90.0;  // Posici√≥n estimada real del brazo

// ========== CALLBACK ESP-NOW ==========
void OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len) {
  memcpy(&receivedData, incomingData, sizeof(receivedData));
  lastReceiveTime = millis();
  digitalWrite(LED_PIN, HIGH);
  
  // --- RECIBIR √ÅNGULOS CALCULADOS DEL GUANTE ---
  float targetServo1 = receivedData.angleServo1;
  float targetServo2 = receivedData.angleServo2;
  
  // --- COMPENSACI√ìN DIFERENCIAL (si MPU brazo disponible) ---
  if (mpuBrazoReady && brazoCalibrated) {
    // Leer posici√≥n real del brazo
    sensors_event_t accel, gyro, temp;
    if (mpuBrazo.getEvent(&accel, &gyro, &temp)) {
      // Aplicar calibraci√≥n y filtrado
      float accelY = accel.acceleration.y - offsetBrazoAccelY;
      float gyroY = gyro.gyro.y - offsetBrazoGyroY;
      
      accelY = filterBrazoAccelY.update(accelY);
      gyroY = filterBrazoGyroY.update(gyroY);
      
      // Estimar √°ngulo real del brazo (similar al filtro complementario)
      float dt = 0.02; // ~50Hz
      float accelAngle = atan2(accelY, 9.8) * 180.0 / PI;
      brazoAngleEstimate += gyroY * dt;
      brazoAngleEstimate = 0.98 * brazoAngleEstimate + 0.02 * accelAngle;
      
      // Mapear a rango servo
      brazoAngleEstimate = map((int)(brazoAngleEstimate * 10), -900, 900, 0, 180);
      brazoAngleEstimate = constrain(brazoAngleEstimate, 0, 180);
      
      // CORRECCI√ìN: Si el brazo est√° desviado, compensar
      float error = brazoAngleEstimate - servo2Position;
      targetServo2 -= error * COMPENSATION_ALPHA; // Aplicar 30% de correcci√≥n
    }
  }
  
  // --- SUAVIZADO INCREMENTAL (anti-tremor) ---
  float diff1 = targetServo1 - servo1Position;
  float diff2 = targetServo2 - servo2Position;
  
  // Limitar velocidad m√°xima de cambio
  if (abs(diff1) > MAX_STEP) diff1 = (diff1 > 0) ? MAX_STEP : -MAX_STEP;
  if (abs(diff2) > MAX_STEP) diff2 = (diff2 > 0) ? MAX_STEP : -MAX_STEP;
  
  servo1Position += diff1;
  servo2Position += diff2;
  
  // Constrain y aplicar
  servo1Position = constrain(servo1Position, 0, 180);
  servo2Position = constrain(servo2Position, 0, 180);
  
  servo1.write((int)servo1Position);
  servo2.write((int)servo2Position);
  
  // --- DEBUG (cada 25 paquetes = 0.5s @ 50Hz) ---
  static int debugCounter = 0;
  if (++debugCounter >= 25) {
    debugCounter = 0;
    Serial.printf("RX: S1=%3.0f¬∞ S2=%3.0f¬∞ | Real=%3.0f¬∞ | GyroZ=%+5.1f¬∞/s AccelY=%+5.2fm/s¬≤\n",
                  servo1Position, servo2Position, brazoAngleEstimate,
                  receivedData.gyroZ, receivedData.accelY);
  }
}

// ========== CALIBRACI√ìN MPU BRAZO ==========
void calibrateBrazo() {
  Serial.println("\nüîß Calibrando MPU del BRAZO...");
  Serial.println("‚ö†Ô∏è Mant√©n el brazo en POSICI√ìN INICIAL (4 seg)");
  
  float sumAccelY = 0, sumGyroY = 0, sumGyroZ = 0;
  int validSamples = 0;
  
  for (int i = 0; i < CALIBRATION_SAMPLES; i++) {
    sensors_event_t accel, gyro, temp;
    if (mpuBrazo.getEvent(&accel, &gyro, &temp)) {
      sumAccelY += accel.acceleration.y;
      sumGyroY += gyro.gyro.y;
      sumGyroZ += gyro.gyro.z;
      validSamples++;
    }
    
    if (i % 25 == 0) {
      Serial.print(".");
      digitalWrite(LED_PIN, !digitalRead(LED_PIN));
    }
    delay(20);
  }
  
  offsetBrazoAccelY = sumAccelY / validSamples;
  offsetBrazoGyroY = sumGyroY / validSamples;
  offsetBrazoGyroZ = sumGyroZ / validSamples;
  brazoCalibrated = true;
  
  Serial.println("\n‚úÖ Calibraci√≥n del brazo OK!");
  Serial.printf("   Offset AccelY: %.3f m/s¬≤\n", offsetBrazoAccelY);
  Serial.printf("   Offset GyroY:  %.3f ¬∞/s\n", offsetBrazoGyroY);
}

// ========== SETUP ==========
void setup() {
  Serial.begin(115200);
  delay(2000);
  pinMode(LED_PIN, OUTPUT);
  
  Serial.println("\n============================================");
  Serial.println("SPRINT 2 - RECEPTOR CON DOBLE MPU");
  Serial.println("============================================\n");
  
  // --- I2C + MPU Brazo (OBLIGATORIO) ---
  Serial.print("Inicializando MPU brazo... ");
  Wire.begin(SDA_PIN, SCL_PIN);
  Wire.setClock(400000);
  delay(100);
  
  if (!mpuBrazo.begin(0x68, &Wire)) {
    // Intentar con direcci√≥n alternativa (MPU6500)
    if (!mpuBrazo.begin(0x70, &Wire)) {
      Serial.println("‚ùå FALLO!");
      Serial.println("‚ö†Ô∏è MPU brazo es OBLIGATORIO para Sprint 2");
      Serial.println("   Verifica conexiones I2C (SDA=8, SCL=10)");
      while (1) {
        digitalWrite(LED_PIN, !digitalRead(LED_PIN));
        delay(300);
      }
    }
  }
  
  mpuBrazo.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpuBrazo.setGyroRange(MPU6050_RANGE_500_DEG);
  mpuBrazo.setFilterBandwidth(MPU6050_BAND_21_HZ);
  mpuBrazoReady = true;
  Serial.println("‚úÖ OK");
  
  // --- Calibraci√≥n MPU brazo ---
  calibrateBrazo();
  
  // --- Servos ---
  Serial.print("Configurando servos... ");
  ESP32PWM::allocateTimer(0);
  ESP32PWM::allocateTimer(1);
  servo1.setPeriodHertz(50);
  servo2.setPeriodHertz(50);
  servo1.attach(SERVO1_PIN, 500, 2400);
  servo2.attach(SERVO2_PIN, 500, 2400);
  
  // Posici√≥n inicial centrada
  servo1.write(90);
  servo2.write(90);
  Serial.println("‚úÖ OK (GPIO6=S1, GPIO7=S2)");
  
  // Test visual
  Serial.print("Test de movimiento... ");
  servo1.write(60); delay(200);
  servo1.write(120); delay(200);
  servo1.write(90); delay(200);
  servo2.write(60); delay(200);
  servo2.write(120); delay(200);
  servo2.write(90);
  Serial.println("‚úÖ OK");
  
  // --- WiFi + ESP-NOW ---
  Serial.print("Inicializando ESP-NOW... ");
  WiFi.mode(WIFI_STA);
  delay(100);
  
  if (esp_now_init() != ESP_OK) {
    Serial.println("‚ùå Error ESP-NOW");
    while (1) { delay(1000); }
  }
  
  esp_now_register_recv_cb(OnDataRecv);
  Serial.println("‚úÖ OK");
  
  Serial.println("\nüöÄ Sistema listo!");
  Serial.println("   - Filtros activos");
  Serial.println("   - Compensaci√≥n diferencial habilitada");
  Serial.println("   - Esperando datos del guante...\n");
  
  // LED de confirmaci√≥n
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(200);
    digitalWrite(LED_PIN, LOW);
    delay(200);
  }
}

// ========== LOOP ==========
void loop() {
  static unsigned long lastStatusPrint = 0;
  unsigned long currentTime = millis();
  
  // Apagar LED despu√©s de recepci√≥n
  if (currentTime - lastReceiveTime > 50) {
    digitalWrite(LED_PIN, LOW);
  }
  
  // Si no hay comunicaci√≥n, mostrar espera (cada 2 segundos)
  if (lastReceiveTime == 0 || (currentTime - lastReceiveTime >= TIMEOUT)) {
    if (currentTime - lastStatusPrint >= 2000) {
      lastStatusPrint = currentTime;
      Serial.println("‚è≥ Esperando se√±al del guante...");
      
      // Timeout: volver gradualmente a posici√≥n neutral
      if (lastReceiveTime > 0) {
        if (abs(servo1Position - 90) > 1) {
          servo1Position += (servo1Position < 90) ? 0.5 : -0.5;
          servo1.write((int)servo1Position);
        }
        if (abs(servo2Position - 90) > 1) {
          servo2Position += (servo2Position < 90) ? 0.5 : -0.5;
          servo2.write((int)servo2Position);
        }
      }
    }
  }
  
  delay(10);
}
